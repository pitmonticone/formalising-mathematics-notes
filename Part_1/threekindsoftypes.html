

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>The three kinds of types &mdash; Formalising Mathematics 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=2709fde1"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Brackets in function inputs" href="brackets.html" />
    <link rel="prev" title="Equality" href="equality.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Formalising Mathematics
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Introduction/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Introduction/install.html">Installing Lean</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Part_1.html">Part 1: Lean tips</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="typesandterms.html">Types and terms</a></li>
<li class="toctree-l2"><a class="reference internal" href="equality.html">Equality</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">The three kinds of types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#function-types-a-k-a-pi-types">Function types (a.k.a. Pi types)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inductive-types">Inductive types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#quotient-types">Quotient types</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="brackets.html">Brackets in function inputs</a></li>
<li class="toctree-l2"><a class="reference internal" href="precedence.html">Notation and precedence</a></li>
<li class="toctree-l2"><a class="reference internal" href="structures.html">Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="dot_notation.html">Dot notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="coercions.html">Coercions</a></li>
<li class="toctree-l2"><a class="reference internal" href="the_axiom_of_choice.html">The axiom of choice</a></li>
<li class="toctree-l2"><a class="reference internal" href="well_formatted_code.html">How to format your code well</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../Part_2/Part_2.html">Part 2: Tactics</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Formalising Mathematics</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="Part_1.html">Part 1: Lean tips</a></li>
      <li class="breadcrumb-item active">The three kinds of types</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/Part_1/threekindsoftypes.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="the-three-kinds-of-types">
<h1>The three kinds of types<a class="headerlink" href="#the-three-kinds-of-types" title="Link to this heading"></a></h1>
<p>This is some background on Lean’s type theory.</p>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h2>
<p>Recall that every expression in Lean lives at one of three “levels” – it is either a universe, a type or a term. The universes are easy to understand; as far as this course is concerned, there are only two, namely <code class="docutils literal notranslate"><span class="pre">Type</span></code> and <code class="docutils literal notranslate"><span class="pre">Prop</span></code>. This document is about the next level down – types. It turns out that at the end of the day there are only three kinds of ways that you can make types; there are function types, inductive types and quotient types. I will go through these three kinds of types in this section, explaining abstractly how to make the type, how to make terms of that type, and how to make functions whose domain is the type.</p>
<p>[A technical footnote about the “meaning” of this section. You might be wondering about the sets and theorem statements you know in mathematics (recall that in Lean the type plays the role of both), and asking yourself which kind of type each of these things is. However such a question is not really mathematically meaningful; for example the type of group homomorphisms between two groups can be made either as an inductive type or a function type, and the quotient of a group by a subgroup can be made as either an inductive type or a quotient type. In fact, it is not completely clear to me that mathematicians need to know the ins and outs of these constructions if all they want to do is to prove theorems, but here is a brief overview anyway. For more detailed information, read Lean’s type theory bible, <a class="reference external" href="https://leanprover.github.io/theorem_proving_in_lean4/">Theorem Proving In Lean</a> (sections 2, 3, 7 and 12).]</p>
<p>[A technical footnote about universes. if you look in the <a class="reference external" href="https://github.com/leanprover-community/mathlib4/">source code</a> of <code class="docutils literal notranslate"><span class="pre">mathlib</span></code> you will find more general Type universes called <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">u</span></code> (our <code class="docutils literal notranslate"><span class="pre">Type</span></code> is just <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">0</span></code>), and you might even see <code class="docutils literal notranslate"><span class="pre">Sort</span> <span class="pre">u</span></code>, which means “either <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">u</span></code> or <code class="docutils literal notranslate"><span class="pre">Prop</span></code>. These “higher universes” are a consequence of the fact that <em>everything</em> in Lean has to have a type, so <code class="docutils literal notranslate"><span class="pre">Type</span></code> has to have a type, and this type is called <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">1</span></code>, which has type <code class="docutils literal notranslate"><span class="pre">Type</span> <span class="pre">2</span></code> etc etc. We’re not doing any category theory in this course, so we will ignore these higher universes.]</p>
</section>
<section id="function-types-a-k-a-pi-types">
<span id="fn-types"></span><h2>Function types (a.k.a. Pi types)<a class="headerlink" href="#function-types-a-k-a-pi-types" title="Link to this heading"></a></h2>
<p>Set-theoretically, if <code class="docutils literal notranslate"><span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">Y</span></code> are sets, we can consider the set <code class="docutils literal notranslate"><span class="pre">Hom(X,Y)</span></code> of maps from <code class="docutils literal notranslate"><span class="pre">X</span></code> to <code class="docutils literal notranslate"><span class="pre">Y</span></code>. In Lean the corresponding type is called <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">→</span> <span class="pre">Y</span></code> so you can think of the <code class="docutils literal notranslate"><span class="pre">→</span></code> symbol as “the way to make this type”.</p>
<p>We make terms of this type using something called <code class="docutils literal notranslate"><span class="pre">fun</span></code>. You can also use <code class="docutils literal notranslate"><span class="pre">λ</span></code> (they
keep meaning to deprecate it but it doesn’t seem to have happened yet. with the annoying
consequence that nobody can use <code class="docutils literal notranslate"><span class="pre">λ</span></code> as a variable – it is a <em>reserved symbol</em> in Lean – it means one thing, and one thing only: it’s the  <code class="docutils literal notranslate"><span class="pre">λ</span></code> in “lambda-calculus”, if you’ve ever heard of that). We’ll use <code class="docutils literal notranslate"><span class="pre">fun</span></code> below.</p>
<p>If you want to make the function <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> from the reals to the reals sending <code class="docutils literal notranslate"><span class="pre">x</span></code> to <code class="docutils literal notranslate"><span class="pre">x^2+3</span></code> then in Lean the definition of <code class="docutils literal notranslate"><span class="pre">f</span></code> looks like this:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">ℝ</span> <span class="bp">→</span> <span class="n">ℝ</span> <span class="o">:=</span> <span class="k">fun</span> <span class="n">x</span> <span class="bp">↦</span> <span class="n">x</span><span class="bp">^</span><span class="mi">2</span><span class="bp">+</span><span class="mi">3</span>
</pre></div>
</div>
<p>The “mapsto” symbol <code class="docutils literal notranslate"><span class="pre">↦</span></code> is typeset with <code class="docutils literal notranslate"><span class="pre">\mapsto</span></code>.</p>
<p>In fact Lean has a slightly more general kind of function type. The idea (expressed set-theoretically) is that if we have infinitely many sets <code class="docutils literal notranslate"><span class="pre">Y₀</span></code>, <code class="docutils literal notranslate"><span class="pre">Y₁</span></code>, <code class="docutils literal notranslate"><span class="pre">Y₂</span></code>,… then we can make the type of functions from the natural numbers to the union of the <code class="docutils literal notranslate"><span class="pre">Yₙ</span></code>, but with the condition that the natural number <code class="docutils literal notranslate"><span class="pre">i</span></code> is sent to an element of <code class="docutils literal notranslate"><span class="pre">Yᵢ</span></code>. More generally (and switching back to type-theoretic language), say  <code class="docutils literal notranslate"><span class="pre">I</span></code> is some index type, and for each <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">:</span> <span class="pre">I</span></code> we have a type <code class="docutils literal notranslate"><span class="pre">Y</span> <span class="pre">i</span></code>. Then Lean will let you make the type of “generalised functions” which take as input a term <code class="docutils literal notranslate"><span class="pre">i</span></code> of type <code class="docutils literal notranslate"><span class="pre">I</span></code> and which spit out a term of type <code class="docutils literal notranslate"><span class="pre">Y</span> <span class="pre">i</span></code> – so the type of the output depends on the term which is input. Lean’s notation for the type of these functions is <code class="docutils literal notranslate"><span class="pre">∀</span> <span class="pre">(i</span> <span class="pre">:</span> <span class="pre">I),</span> <span class="pre">Y</span> <span class="pre">i</span></code>, or <code class="docutils literal notranslate"><span class="pre">∀</span> <span class="pre">i,</span> <span class="pre">Y</span> <span class="pre">i</span></code> for short. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is such a function, then the fact that the type of the output of <code class="docutils literal notranslate"><span class="pre">f</span></code> depends on the term <code class="docutils literal notranslate"><span class="pre">i</span></code> which is input means that <code class="docutils literal notranslate"><span class="pre">f</span></code> is called a “dependent function”, and the type <code class="docutils literal notranslate"><span class="pre">∀</span> <span class="pre">i,</span> <span class="pre">Y</span> <span class="pre">i</span></code> of <code class="docutils literal notranslate"><span class="pre">f</span></code> is called a “dependent type”, or a “Pi type”. Not all theorem provers have dependent types – for example the Isabelle/HOL theorem prover uses a logic called Higher Order Logic, which does not have dependent types.</p>
<p>Dependent types in the <code class="docutils literal notranslate"><span class="pre">Type</span></code> universe started showing up in mathematics in the middle of the 20th century. Those of you who have done some differential geometry might have seen this sort of thing before (if you haven’t then perhaps ignore this paragraph!). The tangent space <code class="docutils literal notranslate"><span class="pre">Tₓ</span></code> of a manifold at a point <code class="docutils literal notranslate"><span class="pre">x</span></code> is a vector space, and these tangent spaces “glue together” to make a tangent bundle, the union of the tangent spaces; a section <code class="docutils literal notranslate"><span class="pre">s</span></code> of the tangent bundle is a function from the manifold to the union of the tangent spaces with the extra hypothesis that <code class="docutils literal notranslate"><span class="pre">s(x)</span></code> is an element of <code class="docutils literal notranslate"><span class="pre">Tₓ</span></code> for all <code class="docutils literal notranslate"><span class="pre">x</span></code>. So a section of the tangent bundle is a term of type <code class="docutils literal notranslate"><span class="pre">Π</span> <span class="pre">(x</span> <span class="pre">:</span> <span class="pre">X),</span> <span class="pre">T</span> <span class="pre">x</span></code>. They also show up in algebraic geometry when you start doing scheme theory (for example Hartshorne’s definition of the structure sheaf on an affine scheme involves the dependent type of functions sending a prime ideal of a commutative ring to an element of the localisation of the ring at this prime ideal).</p>
<p>If the simplest examples I can come up with in mathematics are some fancy differential geometry and algebraic geometry examples, you might wonder whether we need to think about Pi types at all in this course. But in fact in the <code class="docutils literal notranslate"><span class="pre">Prop</span></code> universe they show up all the time! Let’s consider a proof by induction. We have infinitely many true-false statements <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">2</span> <span class="pre">``,...,</span> <span class="pre">and</span> <span class="pre">we</span> <span class="pre">want</span> <span class="pre">to</span> <span class="pre">prove</span> <span class="pre">them</span> <span class="pre">all.</span> <span class="pre">In</span> <span class="pre">other</span> <span class="pre">words,</span> <span class="pre">we</span> <span class="pre">want</span> <span class="pre">to</span> <span class="pre">prove</span> <span class="pre">the</span> <span class="pre">proposition</span> <span class="pre">``∀</span> <span class="pre">n,</span> <span class="pre">P</span> <span class="pre">n</span></code>. This proposition, like all propositions, is a type (in the <code class="docutils literal notranslate"><span class="pre">Prop</span></code> universe) and in fact it is a Pi type, because to give a term of this type, we need to come up with a function which takes as input a natural number <code class="docutils literal notranslate"><span class="pre">n</span></code> and gives as output a proof of <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">n</span></code>, that is, a term of type <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">n</span></code>. So different input terms give terms in different output types. In short, whilst you can do a lot of mathematics without dependent types, we see dependent propositions everywhere. In fact the statement of Fermat’s Last Theorem is a dependent type, because the type <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">^</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">^</span> <span class="pre">n</span> <span class="pre">=</span> <span class="pre">z</span> <span class="pre">^</span> <span class="pre">n</span></code> depends on the terms <code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code> and <code class="docutils literal notranslate"><span class="pre">n</span></code>. Of course it’s possible to state Fermat’s Last Theorem in Isabelle/HOL or another HOL system, however the lack of dependent types might make doing modern algebraic geometry in such a system far more inconvenient.</p>
</section>
<section id="inductive-types">
<span id="ind-types"></span><h2>Inductive types<a class="headerlink" href="#inductive-types" title="Link to this heading"></a></h2>
<p>Inductive types are an extremely flexible kind of type; you make them by basically listing the rules which you will allow to make terms of this type. For example, if you want Lean’s version of “a set <code class="docutils literal notranslate"><span class="pre">X</span></code> with three elements <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">c</span></code>” then you can make it like this:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">a</span> <span class="o">:</span> <span class="n">X</span>
<span class="bp">|</span> <span class="n">b</span> <span class="o">:</span> <span class="n">X</span>
<span class="bp">|</span> <span class="n">c</span> <span class="o">:</span> <span class="n">X</span>
</pre></div>
</div>
<p>We now have a new type <code class="docutils literal notranslate"><span class="pre">X</span></code> in the system, with three terms <code class="docutils literal notranslate"><span class="pre">X.a</span> <span class="pre">:</span> <span class="pre">X</span></code>, <code class="docutils literal notranslate"><span class="pre">X.b</span> <span class="pre">:</span> <span class="pre">X</span></code> and <code class="docutils literal notranslate"><span class="pre">X.c</span> <span class="pre">:</span> <span class="pre">X</span></code>.</p>
<p>So that’s now to make an inductive type, and how to make terms of this type. The remaining question is how to define functions from this type, or equivalently how to use terms of this type. If you want to make a function from this type, then instead of using <code class="docutils literal notranslate"><span class="pre">fun</span></code> you can use Lean’s “equation compiler”. Here’s how to define the function from <code class="docutils literal notranslate"><span class="pre">X</span></code> to the naturals sending <code class="docutils literal notranslate"><span class="pre">X.a</span></code> to <code class="docutils literal notranslate"><span class="pre">37</span></code>, <code class="docutils literal notranslate"><span class="pre">X.b</span></code> to <code class="docutils literal notranslate"><span class="pre">42</span></code> and <code class="docutils literal notranslate"><span class="pre">X.c</span></code> to 0:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">X.a</span> <span class="bp">=&gt;</span> <span class="mi">37</span>
<span class="bp">|</span> <span class="n">X.b</span> <span class="bp">=&gt;</span> <span class="mi">42</span>
<span class="bp">|</span> <span class="n">X.c</span> <span class="bp">=&gt;</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Note that if you <code class="docutils literal notranslate"><span class="pre">open</span> <span class="pre">X</span></code> then you don’t have to keep putting <code class="docutils literal notranslate"><span class="pre">X.</span></code> everywhere. It is
a source of some annoyance to some people that you can’t use <code class="docutils literal notranslate"><span class="pre">\mapsto</span></code> here, and have
to use this ASCII art <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> instead.</p>
<p>You might think that this kind of construction can only make finite types, but in fact the theory of inductive types is far more powerful than this, and in particular we can make many infinite types with them. For example the definition of the natural numbers in Lean looks like this:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">Nat</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">zero</span> <span class="o">:</span> <span class="n">Nat</span>
  <span class="bp">|</span> <span class="n">succ</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="n">Nat</span><span class="o">)</span> <span class="o">:</span> <span class="n">Nat</span>
</pre></div>
</div>
<p>(Peano observed that these two construtions were enough to define all natural numbers) and then mathlib sets up the notation <code class="docutils literal notranslate"><span class="pre">ℕ</span></code> for <code class="docutils literal notranslate"><span class="pre">Nat</span></code> later. If you’ve played the natural number game you’ll know that we can define addition and multiplication on the natural numbers, and once one has these set up one can define functions from the naturals to the naturals or other types using <code class="docutils literal notranslate"><span class="pre">fun</span></code>, for example <code class="docutils literal notranslate"><span class="pre">fun</span> <span class="pre">(n</span> <span class="pre">:</span> <span class="pre">ℕ)</span> <span class="pre">↦</span> <span class="pre">2*n+3</span></code> defines a function from <code class="docutils literal notranslate"><span class="pre">ℕ</span></code> to <code class="docutils literal notranslate"><span class="pre">ℕ</span></code>. However we can also use the equation compiler to inductively define (or more precisely, recursively define) functions from the naturals. For example the sequence defined by <code class="docutils literal notranslate"><span class="pre">a(0)=3</span></code> and <code class="docutils literal notranslate"><span class="pre">a(n+1)=a(n)^2+37</span></code> could be defined like this:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">def</span> <span class="n">a</span> <span class="o">:</span> <span class="n">ℕ</span> <span class="bp">→</span>  <span class="n">ℕ</span>
<span class="bp">|</span> <span class="n">Nat.zero</span> <span class="bp">=&gt;</span> <span class="mi">3</span>
<span class="bp">|</span> <span class="n">Nat.succ</span> <span class="n">n</span> <span class="bp">=&gt;</span> <span class="o">(</span><span class="n">a</span> <span class="n">n</span><span class="o">)</span><span class="bp">^</span><span class="mi">2</span> <span class="bp">+</span> <span class="mi">37</span>
</pre></div>
</div>
<p>You can make inductive propositions too. For example here are the definitions of <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code> in Lean:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">True</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
  <span class="bp">|</span> <span class="n">intro</span> <span class="o">:</span> <span class="n">True</span>

<span class="kd">inductive</span> <span class="n">False</span> <span class="o">:</span> <span class="kt">Prop</span>
</pre></div>
</div>
<p>The inductive type <code class="docutils literal notranslate"><span class="pre">True</span></code> has one constructor (called <code class="docutils literal notranslate"><span class="pre">True.intro</span></code>); the inductive type <code class="docutils literal notranslate"><span class="pre">False</span></code> has no constructors. Remember that we model truth and falsehood of propositions in Lean by whether the corresponding type has a term or not. Faced with a goal of <code class="docutils literal notranslate"><span class="pre">⊢</span> <span class="pre">True</span></code> you can prove it with <code class="docutils literal notranslate"><span class="pre">exact</span> <span class="pre">True.intro</span></code>. You cannot make a term of type <code class="docutils literal notranslate"><span class="pre">False</span></code> “absolutely” – the only time it can happen is if you are in a “relative” situation where you have hypotheses, some of which are contradictory.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">Q</span></code> are Propositions, then you can use inductive types to make the propositions <code class="docutils literal notranslate"><span class="pre">And</span> <span class="pre">P</span> <span class="pre">Q</span></code> and <code class="docutils literal notranslate"><span class="pre">Or</span> <span class="pre">P</span> <span class="pre">Q</span></code>, with notations <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">∧</span> <span class="pre">Q</span></code> and <code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">∨</span> <span class="pre">Q</span></code>. Here are their definitions:</p>
<div class="highlight-lean notranslate"><div class="highlight"><pre><span></span><span class="kd">inductive</span> <span class="n">And</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">intro</span> <span class="o">(</span><span class="n">hp</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">(</span><span class="n">hq</span> <span class="o">:</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="n">And</span> <span class="n">P</span> <span class="n">Q</span>

<span class="kd">inductive</span> <span class="n">Or</span> <span class="o">(</span><span class="n">P</span> <span class="n">Q</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="n">where</span>
<span class="bp">|</span> <span class="n">intro_left</span> <span class="o">(</span><span class="n">hP</span> <span class="o">:</span> <span class="n">P</span><span class="o">)</span> <span class="o">:</span> <span class="n">Or</span> <span class="n">P</span> <span class="n">Q</span>
<span class="bp">|</span> <span class="n">intro_right</span> <span class="o">(</span><span class="n">hQ</span> <span class="o">:</span> <span class="n">Q</span><span class="o">)</span> <span class="o">:</span> <span class="n">Or</span> <span class="n">P</span> <span class="n">Q</span>
</pre></div>
</div>
<p>If you do <code class="docutils literal notranslate"><span class="pre">cases</span> <span class="pre">h</span></code> with <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">∧</span> <span class="pre">Q</span></code> then, because <code class="docutils literal notranslate"><span class="pre">And</span></code> has one constructor (<code class="docutils literal notranslate"><span class="pre">And.intro</span></code>), you end up with one goal. If you do <code class="docutils literal notranslate"><span class="pre">cases</span> <span class="pre">h</span></code> with <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">P</span> <span class="pre">∨</span> <span class="pre">Q</span></code> then you end up with two goals, because <code class="docutils literal notranslate"><span class="pre">Or</span></code> has two constructors (<code class="docutils literal notranslate"><span class="pre">Or.intro_left</span></code> and <code class="docutils literal notranslate"><span class="pre">Or.intro_right</span></code>). If you do <code class="docutils literal notranslate"><span class="pre">cases</span> <span class="pre">h</span></code> with <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">:</span> <span class="pre">False</span></code> then you end up with no goals, because <code class="docutils literal notranslate"><span class="pre">False</span></code> has no constructors. When Lean sees that there are no goals left, it prints <code class="docutils literal notranslate"><span class="pre">no</span> <span class="pre">goals</span></code>; if you have no goals left, you’ve proved the result you were trying to prove. It took me some time to recalibrate my thinking to this “inductive” way of thinking about logic.</p>
<p>We say “let <code class="docutils literal notranslate"><span class="pre">G</span></code> be a group” in Lean using inductive types, but the types involved are very simple inductive types with only one constructor. The type <code class="docutils literal notranslate"><span class="pre">Group</span> <span class="pre">G</span></code> is the type of group structures on <code class="docutils literal notranslate"><span class="pre">G</span></code>. There is only way to make a term of type <code class="docutils literal notranslate"><span class="pre">Group</span> <span class="pre">G</span></code> – you have to give a multiplication on <code class="docutils literal notranslate"><span class="pre">G</span></code>, an identity and an inverse function, and then check that it satisfies the group axioms. So the inductive type <code class="docutils literal notranslate"><span class="pre">Group</span> <span class="pre">G</span></code> has just one constructor which takes all of this data as input and then outputs a term of type <code class="docutils literal notranslate"><span class="pre">Group</span> <span class="pre">G</span></code>. We will talk more about how to make the inductive type <code class="docutils literal notranslate"><span class="pre">Group</span> <span class="pre">G</span></code> when we get on to groups in section 5.</p>
</section>
<section id="quotient-types">
<h2>Quotient types<a class="headerlink" href="#quotient-types" title="Link to this heading"></a></h2>
<p>The third kind of type which you can make in Lean is a quotient type, which I mention here only for completeness. Lean does not actually need this kind of type – it is possible to make quotient types explicitly using inductive types. However for technical reasons (which mathematicians don’t need to worry about) they are a distinct primitive kind of type in Lean. The basic set-up is that you have a type <code class="docutils literal notranslate"><span class="pre">X</span></code> and an equivalence relation <code class="docutils literal notranslate"><span class="pre">R</span></code> on <code class="docutils literal notranslate"><span class="pre">X</span></code> (for some reason this is referred to as a term of type <code class="docutils literal notranslate"><span class="pre">Setoid</span> <span class="pre">X</span></code> in Lean), and you want to make the quotient of <code class="docutils literal notranslate"><span class="pre">X</span></code> by <code class="docutils literal notranslate"><span class="pre">R</span></code>. This is the type which mathematicians would typically refer to as “the set of equivalence classes of <code class="docutils literal notranslate"><span class="pre">R</span></code>”. In Lean it’s called <code class="docutils literal notranslate"><span class="pre">Quotient</span> <span class="pre">R</span></code>, and the map from <code class="docutils literal notranslate"><span class="pre">X</span></code> to <code class="docutils literal notranslate"><span class="pre">Quotient</span> <span class="pre">R</span></code> is called <code class="docutils literal notranslate"><span class="pre">Quotient.mk</span> <span class="pre">R</span> <span class="pre">:</span> <span class="pre">X</span> <span class="pre">→</span> <span class="pre">Quotient</span> <span class="pre">R</span></code>. In particular you can make terms of type <code class="docutils literal notranslate"><span class="pre">Quotient</span> <span class="pre">R</span></code> by applying <code class="docutils literal notranslate"><span class="pre">Quotient.mk</span></code> to terms of type <code class="docutils literal notranslate"><span class="pre">X</span></code> (this is just the construction sending an element of <code class="docutils literal notranslate"><span class="pre">X</span></code> to its equivalence class). To define a function <em>from</em> <code class="docutils literal notranslate"><span class="pre">Quotient</span> <span class="pre">R</span></code> we use the <code class="docutils literal notranslate"><span class="pre">Quotient.lift</span></code> function; more on this later, when we construct some quotient types familiar to mathematicians.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="equality.html" class="btn btn-neutral float-left" title="Equality" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="brackets.html" class="btn btn-neutral float-right" title="Brackets in function inputs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Bhavik Mehta.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>